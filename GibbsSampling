import numpy as np
from util import logsumexp
from MarkovNet import MarkovNet
import pandas as pd
import random
from collections import Counter

class Gibbs(object):
    "Object that can run gibbs sampling on a MarkovNet"

    def __init__(self, markovNet):
        """Initialize belief propagator for markovNet."""
        self.mn = markovNet
        self.States = dict()
        self.Unaryweights = dict()
        self.Samples = list()

    def weighted_choice(self, weight):
        """Generate state according to the given weight"""
        rnd = random.random() * sum(weight)
        for i, w in enumerate(weight):
            rnd = rnd - w
            if rnd < 0:
                return i

    def initStates(self):
        """Initialize the state of each node."""
        for var in self.mn.variables:
            weight = self.mn.getUnaryPotential(var)
            logZ = logsumexp(weight)
            weight = weight - logZ
            weight = np.exp(weight)
            self.Unaryweights[var] = weight;
            self.States[var] = self.weighted_choice(self.Unaryweights[var])

    def updateStates(self):
        """Update the state of each node based on neighbor states."""
        for var in self.mn.variables:
            weight = self.mn.getUnaryPotential(var)
            for neighbor in self.mn.neighbors[var]:
                weight =  weight + self.mn.getPotential((var,neighbor))[:, self.getStates(neighbor)]
                logZ = logsumexp(weight)
                weight = weight - logZ
                weight = np.exp(weight)
            self.States[var] = self.weighted_choice(weight)

    def getStates(self, variable):
        return self.States[variable]

    def mix(self, ite):
        """Run the state Update procedure until mix, ite: number of iterations for mixing"""
        for i in range(0, ite):
                self.updateStates()

    def Sampling(self, num, s):
        """Run the sampling: num, number of samples; s, gap between two samples (So when s = 1, means take consecutive samples)"""
        for i in range(0, num):
            self.updateStates()
            self.Samples.append(self.States.copy())
        for i in range(0, s-1):
            self.updateStates()

    def counter(self, Samples):
        for var in self.mn.variables:
            counts = Counter(pd.DataFrame(Samples)[var])
            print(counts)

    def GibbsSampling(self, itr, num, s):
        self.mix(itr)
        self.Sampling(num, s)
        self.counter(self.Samples)


def main():
    # """Test basic functionality of BeliefPropagator."""
    mn = MarkovNet()

    np.random.seed(1)

    mn.setUnaryFactor(0, np.random.randn(4))
    mn.setUnaryFactor(1, np.random.randn(3))
    mn.setUnaryFactor(2, np.random.randn(6))
    mn.setUnaryFactor(3, np.random.randn(2))

    mn.setEdgeFactor((0,1), np.random.randn(4,3))
    mn.setEdgeFactor((1,2), np.random.randn(3,6))
    mn.setEdgeFactor((3,2), np.random.randn(2,6))
    mn.setEdgeFactor((3,0), np.random.randn(2,4)) # uncomment this to make loopy

    gb = Gibbs(mn)
    gb.initStates()
    print(gb.States)

    Itr = 10000
    Num = 1000
    s = 1
    gb.GibbsSampling(Itr, Num, s)


if  __name__ =='__main__':
    main()
